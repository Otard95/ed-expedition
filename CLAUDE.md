# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

---

## ⚠️ CRITICAL: Live Reload Environment

**THE USER RUNS `wails dev` WITH LIVE RELOAD - DO NOT MANUALLY BUILD**

- The development environment automatically rebuilds on file changes
- Frontend changes trigger instant Vite hot reload
- Backend changes trigger Go recompilation and app restart
- Wails auto-regenerates TypeScript bindings when Go code changes
- **DO NOT run `pnpm run build`, `go build`, or `wails build` unless explicitly requested**
- **DO NOT run `wails generate module` - bindings generate automatically**

Focus on writing code - the build system handles everything automatically.

---

## ⚠️ CRITICAL: Comment Policy

**COMMENTS EXPLAIN WHY, NOT WHAT**

- **NEVER write comments that explain WHAT the code does** - the code itself should be self-documenting through clear naming and structure
- **ONLY write comments that explain WHY the code does what it does** - reasoning, business logic, non-obvious decisions, workarounds
- **EXCEPTION:** LSP hover documentation comments are allowed, but use sparingly - if you need them frequently, it indicates naming needs improvement

**Examples:**

❌ **BAD** (explains WHAT):
```go
// Loop through all routes
for _, route := range routes {
    // Check if route ID matches
    if route.ID == targetID {
        // Return the route
        return route
    }
}
```

✅ **GOOD** (explains WHY):
```go
// We iterate all routes instead of using a map because routes are rarely accessed
// by ID during normal operation, and the memory overhead isn't justified
for _, route := range routes {
    if route.ID == targetID {
        return route
    }
}
```

---

## Project Overview

This is a Wails v2 application for Elite Dangerous expedition management. The project is porting expedition features from a Python codebase to Go, implementing a desktop app with Go backend and Svelte frontend.

**Key Documentation:**
- `SPEC.md` - Feature specification for Expeditions
- `SPEC_DECISIONS.md` - Detailed design decisions and data structures
- `MODEL_DECISIONS.md` - Model implementation decisions (Python → Go port considerations)
- `SPEC_REVIEW.md` - Comprehensive design analysis and edge cases
- `frontend/FRONTEND.md` - Frontend stack, component architecture, Wails integration patterns, Elite Dangerous theming, current implementation state

## Architecture

### Stack
- **Backend:** Go with Wails v2 framework
- **Frontend:** Svelte + TypeScript + Vite
- **Development:** Nix flake for reproducible dev environment

### Core Concepts

**Expeditions are non-linear graphs of route segments:**
- Routes are immutable, reusable path libraries (generated by external plotters like Spansh)
- Routes connect via unidirectional links at identical systems (same system_id)
- Example path: `RouteA[0-20] → RouteB[5-10] → RouteA[35-50]`
- You navigate portions of routes, not complete them sequentially

**Critical Features:**
1. **Baked Routes** - When expedition becomes active, the complete path is pre-computed into a flat array for O(1) lookups
2. **Auto-Copy to Clipboard** - After every FSDJump, automatically copy next system name (killer feature for in-game navigation)
3. **Deviation Tracking** - Record ALL jumps (on-route and off-route) with complete history
4. **State Machine** - Four states: `planned` → `active` → `completed`/`ended`

**Design Philosophy:**
- Routes are immutable snapshots from plotter (never edited after creation)
- Trust the plotter (Spansh) - minimal validation beyond link structure
- Track everything, no complex recovery logic for deviations
- Single active expedition at a time (multiple planned/completed allowed)

### Frontend Component Design

**Component Philosophy: Simple, Generic, Composable**

Reusable components should be generic and minimal. They provide styling primitives, not layout decisions.

**Rules:**
1. **Generic components handle styling only**
   - Padding, border, shadow, rounded corners, colors
   - Variants for different visual styles
   - Accept `class` prop for consumer overrides

2. **Content consumers control layout**
   - Parent decides: flexbox, grid, stack direction, spacing
   - Components use default slot without layout opinions
   - No hardcoded internal layout assumptions

3. **Component hierarchy follows atomic design**
   - **Atoms**: Card, Button, Badge, Typography (pure styling)
   - **Molecules**: ExpeditionCard, DateFormatter (simple compositions)
   - **Organisms**: ExpeditionList, complex feature components
   - **Pages**: Route-level views

**Examples:**

✅ **GOOD** - Card component:
```svelte
<!-- Card.svelte - just a styled box -->
<script lang="ts">
  export let variant: 'default' | 'highlighted' = 'default';
  export let padding: string = '1rem';
  let className: string = '';
  export { className as class };
</script>

<div class="card {variant} {className}" style="padding: {padding}">
  <slot />
</div>

<style>
  .card { border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
  /* Consumer controls layout of children via slot */
</style>
```

❌ **BAD** - Card with layout opinions:
```svelte
<!-- Don't do this - hardcoded flexbox layout -->
<div class="card" style="display: flex; flex-direction: column; gap: 1rem;">
  <div class="header"><slot name="header" /></div>
  <div class="body"><slot /></div>
</div>
```

## Development Commands

### Setup
```bash
# Enter Nix development environment (provides Go, Node, pnpm, Wails)
nix develop

# Install frontend dependencies
cd frontend && pnpm install
```

### Development
```bash
# Run in live development mode (hot reload)
wails dev

# Development server runs at http://localhost:34115 for browser testing
```

### Building
```bash
# Build production package
wails build

# Output: ./build/bin/ed-expedition (platform-specific)
```

### Frontend Only
```bash
cd frontend
pnpm run dev    # Vite dev server
pnpm run build  # Production build
```

## Data Structures

### Storage Format

OS-specific data directories (via `database.GetOSDataDir()`):
- **Windows:** `%APPDATA%\ed-expedition\`
- **macOS:** `~/Library/Application Support/ed-expedition/`
- **Linux:** `~/.local/share/ed-expedition/` (respects `XDG_DATA_HOME`)

```
ed-expedition/
  app-state.json          # Current ship loadout (minimal fields for spansh)
  index.json              # Active expedition ID + list of all expeditions
  expeditions/
    {expedition_id}.json  # Individual expeditions
  routes/
    {route_id}.json       # Individual routes
```

### Key Models (from SPEC_DECISIONS.md)

**Route** (immutable):
- Unique ID, name, plotter parameters
- Array of jumps (system_name, system_id, position, fuel, scoopable, etc.)
- Created once, never modified

**Expedition**:
- Start point (route_id + jump_index, can start mid-route)
- Routes array (library of available routes)
- Links array (connections between routes at identical systems)
- Baked route (flat array, computed when active)
- Jump history (complete record of all jumps taken)
- State: planned/active/completed/ended

**Link** (unidirectional):
- System name/ID (must match in both routes)
- From: route_id + jump_index (cached)
- To: route_id + jump_index (cached)

**Baked Route** (active expeditions only):
- Pre-computed flat array of all jumps in order
- `current_baked_index` tracks progress
- `baked_loop_back_index` for circular routes (null if non-circular)

## Implementation Patterns

### Model Architecture (from MODEL_DECISIONS.md)

**Python → Go Port Considerations:**
- Original Python used `__slots__` classes
- Go equivalents: structs with JSON tags
- All models need `MarshalJSON`/`UnmarshalJSON` for file I/O
- Nested objects must be validated (e.g., Link.from_pos and Link.to_pos are required)

### Validation Rules

**What gets validated:**
- Link system_id must match in both routes at specified jump indices
- No multiple outgoing links from same (route_id, jump_index) position
- Cycle detection when creating links (warn user, don't block)

**What does NOT get validated:**
- Fuel requirements (trust plotter)
- Jump range feasibility (trust plotter)
- Distance consistency (trust plotter)
- Permit requirements (user responsibility)

### FSDJump Processing Logic

When processing Elite Dangerous journal FSDJump events:

1. Get next expected system from `baked_route[current_baked_index + 1]`
2. Compare jump system_id with expected
3. Record in jump_history with flags: `on_route`, `expected`
4. If on-route: increment `current_baked_index` (or wrap to `baked_loop_back_index` if circular)
5. If reached end and non-circular: transition to `completed`
6. **Always copy next expected system to clipboard** (even during deviations)

### State Transitions

- `planned` → `active`: Bake route, lock structure, start tracking
- `active` → `completed`: Auto-detect when reached end (non-circular only)
- `active` → `ended`: Manual stop (with confirmation)
- No reverse transitions (immutable historical records)

## Critical Design Decisions

1. **Routes are immutable** - No editing after creation. Need changes? Generate new route.
2. **One active expedition** - Enforced at index.json level
3. **Links connect identical systems** - Same system_id in both routes, different jump indices
4. **No branching during travel** - Path must be unambiguous (max one outgoing link per position)
5. **Circular routes allowed** - Detected via `baked_loop_back_index`, must be manually ended
6. **Save after every FSDJump** - ~40+ seconds between jumps, I/O not a concern

## Edge Cases & Gotchas

1. **System appears multiple times in route** - Valid! Each occurrence can have different link
2. **Circular expeditions** - Never auto-complete, must manually end
3. **Starting mid-route** - Expedition.start can point to any jump_index, not just 0
4. **Unlinked routes in expedition** - Valid! Routes are a library, not all need to be connected
5. **Jump index caching** - Link jump indices are cached; validate on load, search route if invalid
6. **Empty routes not allowed** - Must have at least 1 jump
7. **Missing jumps (app offline)** - On startup, detect position mismatch, optionally fill synthetic history

## v1 Scope

**In scope:**
- Spansh plotter only
- Full state machine (planned/active/completed/ended)
- Baked routes with circular support
- Auto-copy to clipboard
- Complete deviation tracking
- JSON file storage

**Out of scope:**
- Multiple plotter support
- Multi-device sync
- Expedition cloning
- Route editing
- Ship change detection
- Advanced validation (fuel, range, permits)

## File Organization

**Naming conventions:**
- Go packages/files: `snake_case` (e.g., `app_state.go`, `spansh_data.go`)
- Cmd binaries: `kebab-case` (e.g., `cmd/journal-watcher-test/`)

**Directory structure:**
```
/
├── main.go              # Wails app entry point (requires -j flag for journal dir)
├── app.go               # Main app struct with exported methods
├── cmd/                 # Standalone utilities (kebab-case naming)
│   ├── journal-watcher-test/    # Test journal monitoring
│   ├── simulate-log/            # Simulate journal writes
│   ├── expected-events/         # Show expected events from test data
│   └── prune-spansh-data/       # Strip spansh.data.json to minimal fields
├── database/            # JSON file I/O and OS-specific data paths
│   ├── json.go          # ReadJSON[T], WriteJSON[T] (atomic writes)
│   └── directories.go   # PathFor, GetDataDir, AppStatePath, IndexPath
├── journal/             # Elite Dangerous journal event processing
│   ├── watcher.go       # File watching with fsnotify, fanout channels
│   └── events.go        # Event type definitions (FSDJump, Loadout, FSDTarget)
├── models/              # Data structures (snake_case files)
│   ├── route.go         # Immutable route from plotter
│   ├── expedition.go    # Expedition state machine
│   ├── index.go         # ExpeditionIndex (active expedition tracking)
│   └── app_state.go     # AppState with minimal Loadout for spansh params
├── services/            # Business logic layer
│   ├── app_state.go     # Tracks loadout from journal, updates app state
│   └── expedition.go    # Expedition lifecycle and FSDJump processing
├── plotters/            # Plotter integration
│   ├── spansh_data.go   # go:embed spansh reference data (FSD modules, boosters)
│   └── spansh.data.json # Pruned spansh data (embedded in binary)
├── lib/                 # Shared utilities
│   ├── channels/fanout.go  # Generic fanout channel for pub/sub
│   ├── slice/main.go       # Find, Split, Count helpers
│   └── fs/main.go          # IsDir helper
└── frontend/
    ├── FRONTEND.md          # Frontend documentation (stack, patterns, theming)
    └── src/
        ├── App.svelte
        ├── components/      # Generic reusable UI components
        ├── features/        # Feature-specific components (expeditions/, routes/)
        ├── lib/
        │   └── utils/       # Shared utilities (date formatting, etc.)
        └── wailsjs/         # Generated Go bindings
```

## Architecture Patterns

### Service Layer

Services handle business logic and event orchestration. Each service:
- Has `Start()` / `Stop()` methods for lifecycle management
- Stores subscription channels for cleanup
- Uses fanout channels from journal watcher for events

**Example pattern:**
```go
type AppStateService struct {
    state       *models.AppState
    watcher     *journal.Watcher
    loadoutChan chan *journal.LoadoutEvent  // Store for cleanup
}

func (s *AppStateService) Start() {
    s.loadoutChan = s.watcher.Loadout.Subscribe()
    go func() {
        for event := range s.loadoutChan {
            // Process event, update state, save
        }
    }()
}

func (s *AppStateService) Stop() {
    if s.loadoutChan != nil {
        s.watcher.Unsubscribe(s.loadoutChan)
        s.loadoutChan = nil  // Prevent double-cleanup
    }
}
```

### Database Layer

**Atomic writes:** `database.WriteJSON` uses temp file + rename pattern to prevent corruption.

**Generic functions:** `ReadJSON[T]` and `WriteJSON[T]` use Go generics for type safety.

**Model persistence:** Package-level `Load*` and `Save*` functions (not methods).

### Plotter System

**Interface Design** (`plotters/main.go`):
```go
type Plotter interface {
    Plot(from, to string, inputs PlotterInputs, loadout *models.Loadout) (*models.Route, error)
    InputConfig() PlotterInputConfig
}
```

**Input Configuration**:
- `PlotterInputType`: Matches JS `typeof` - `string`, `number`, `boolean`
- `PlotterInputFieldConfig`: Defines input field with `Type`, `Default`, `Info` (description), `Options` (for selects)
- `PlotterInputOption`: Select options with `Value`, `Label`, `Description`
- `PlotterInputs`: `map[string]string` - all values encoded as strings
- **Value Encoding**: Bools as "1"/"0", numbers as string floats, strings direct
- **Select Inputs**: Any type can have `Options` to render as dropdown

**Helper Functions** (package-level in `plotters/main.go`):
- `getBoolInput()`, `getNumberInput()`, `getStringInput()` - Get with defaults
- `encodeBool()` - Convert bool to "1"/"0"
- `parseFloat()` - String to float64
- `resolveOptional()`, `oneOf()`, `get()` - Pointer helpers for nil handling

**Spansh Galaxy Plotter** (`plotters/spansh_galaxy_plotter.go`):
- **Embedded data**: `plotters/spansh.data.json` embedded via `go:embed`
- **Input config**: All routing options with descriptions from Spansh UI
- **Query params**: Builds complete parameter set including loadout-derived values (optimal_mass, fuel_multiplier, etc.)
- **FSD/Booster lookup**: Uses embedded spanshData for module defaults
- **Prune utility**: `cmd/prune-spansh-data` strips full spansh data to minimal required fields

### Wails Bindings Pattern

Adding backend functionality exposed to frontend follows this layered approach:

**1. Service Layer** (`services/`):
- Implement business logic in the appropriate service
- Handle domain-specific operations (validation, state management, persistence)
- Services are injected into App via constructor
- Example: `ExpeditionService.RemoveRouteFromExpedition()`

**2. App Layer** (`app.go`):
- Export methods on `App` struct - these become JavaScript bindings
- Methods should orchestrate, not implement - call services, load models, coordinate operations
- Keep thin - delegate complex logic to services
- Handle cross-service coordination if needed
- Example: `PlotRoute()` - gets loadout from AppStateService, calls plotter, adds route via ExpeditionService

**3. Model Layer** (`models/`):
- Package-level `Load*` and `Save*` functions for persistence
- Methods on models for computed properties or validation (e.g., `IsEditable()`)
- Struct fields with JSON tags for serialization

**4. Auto-Generated Bindings**:
- Wails auto-generates TypeScript definitions from exported App methods
- Types generated in `frontend/wailsjs/go/main/App.d.ts` and `App.js`
- Model types in `frontend/wailsjs/go/models.ts`
- Live reload during `wails dev` regenerates bindings automatically

**5. Frontend Integration** (`frontend/src/`):
- Import from `wailsjs/go/main/App`
- Call async - all bindings return Promises
- Handle errors appropriately (user-facing messages, console logs)
- Reload data after mutations to sync with backend state
- Example: `await RemoveRouteFromExpedition(expeditionId, routeId)`

**Important considerations:**
- Return types must be JSON-serializable
- Error handling: return `error` in Go, handle in frontend
- State updates: backend is source of truth - reload after mutations
- No manual binding generation needed - Wails handles it

**Example flow (removing a route):**
1. Service: `RemoveRouteFromExpedition()` - validates, modifies expedition, saves
2. App: `RemoveRouteFromExpedition()` - delegates to service
3. Wails: Auto-generates TS bindings
4. Frontend: Calls binding, handles response, reloads expedition data

## Important Notes

- **Journal integration:** App requires `-j` flag pointing to Elite Dangerous journal directory
- **Clipboard:** Auto-copy system name after each jump (no manual interaction)
- **Thread safety:** Use mutex locks for concurrent access to expedition state
- **Error handling:** WIP - currently using panics for early development, needs proper handling
- **Nil safety:** Go does NOT auto-handle nil - always check before dereferencing pointers
