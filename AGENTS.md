# AGENTS.md

This file provides guidance to AI coding agents when working with code in this repository.

---

## ⚠️ CRITICAL: Live Reload Environment

**DO NOT MANUALLY BUILD** - The user runs `wails dev` with live reload. Frontend and backend rebuild automatically on file changes. Do not run `pnpm run build`, `go build`, `wails build`, or `wails generate module`.

See `wails` skill for details on bindings generation, webkit variants, and build structure.

---

## ⚠️ CRITICAL: Comment Policy

**COMMENTS EXPLAIN WHY, NOT WHAT**

- **NEVER write comments that explain WHAT the code does** - the code itself should be self-documenting through clear naming and structure
- **ONLY write comments that explain WHY the code does what it does** - reasoning, business logic, non-obvious decisions, workarounds
- **EXCEPTION:** LSP hover documentation comments are allowed, but use sparingly - if you need them frequently, it indicates naming needs improvement

**Examples:**

❌ **BAD** (explains WHAT):
```go
// Loop through all routes
for _, route := range routes {
    // Check if route ID matches
    if route.ID == targetID {
        // Return the route
        return route
    }
}
```

✅ **GOOD** (explains WHY):
```go
// We iterate all routes instead of using a map because routes are rarely accessed
// by ID during normal operation, and the memory overhead isn't justified
for _, route := range routes {
    if route.ID == targetID {
        return route
    }
}
```

---

## ⚠️ CRITICAL: Issue Tracking

**USE GITHUB ISSUES FOR BUGS AND FEATURES**

When work is deferred, bugs are found, or features are requested, create a GitHub issue using `gh` CLI (with `pass-env ghc`):

```bash
pass-env ghc gh issue create \
  --title "Issue title" \
  --label "bug,priority:high" \
  --body "Description with context"
```

**Available labels:**
- Type: `bug`, `enhancement`, `tech-debt`, `documentation`
- Priority: `priority:critical`, `priority:high`, `priority:medium`, `priority:low`
- Status: `status:todo`, `status:needs-verification`
- Scope: `scope:future`

**What goes where:**
- **GitHub Issues:** Bugs, features, anything user-facing or worth tracking long-term
- **TODO.md:** Internal tech debt, vague ongoing items, developer notes

**Before starting work**, check open issues:
```bash
pass-env ghc gh issue list --label "priority:critical" --state open
```

**When closing issues**, reference the fix:
```bash
pass-env ghc gh issue close 42 --comment "Fixed in commit abc123"
```

---

## Project Overview

This is a Wails v2 application for Elite Dangerous expedition management. The project is porting expedition features from a Python codebase to Go, implementing a desktop app with Go backend and Svelte frontend.

## Architecture

### Stack
- **Backend:** Go with Wails v2 framework
- **Frontend:** Svelte + TypeScript + Vite
- **Development:** Nix flake for reproducible dev environment

### Core Concepts

**Expeditions are non-linear graphs of route segments:**
- Routes are immutable, reusable path libraries (generated by external plotters like Spansh)
- Routes connect via unidirectional links at identical systems (same system_id)
- Example path: `RouteA[0-20] → RouteB[5-10] → RouteA[35-50]`
- You navigate portions of routes, not complete them sequentially

**Critical Features:**
1. **Baked Routes** - When expedition becomes active, the complete path is pre-computed into a flat array for O(1) lookups
2. **Auto-Copy to Clipboard** - After every FSDJump, automatically copy next system name (killer feature for in-game navigation)
3. **Deviation Tracking** - Record ALL jumps (on-route and off-route) with complete history
4. **State Machine** - Four states: `planned` → `active` → `completed`/`ended`

**Design Philosophy:**
- Routes are immutable snapshots from plotter (never edited after creation)
- Trust the plotter (Spansh) - minimal validation beyond link structure
- Track everything, no complex recovery logic for deviations
- Single active expedition at a time (multiple planned/completed allowed)



## Data Structures

### Storage Format

OS-specific data directories (via `database.GetOSDataDir()`):
- **Windows:** `%APPDATA%\ed-expedition\`
- **macOS:** `~/Library/Application Support/ed-expedition/`
- **Linux:** `~/.local/share/ed-expedition/` (respects `XDG_DATA_HOME`)

```
ed-expedition/
  app-state.json          # Current ship loadout (minimal fields for spansh)
  index.json              # Active expedition ID + list of all expeditions
  expeditions/
    {expedition_id}.json  # Individual expeditions
  routes/
    {route_id}.json       # Individual routes
```

### Key Models

**Route** (immutable):
- Unique ID, name, plotter parameters
- Array of jumps (system_name, system_id, position, fuel, scoopable, etc.)
- Created once, never modified

**Expedition**:
- Start point (route_id + jump_index, can start mid-route)
- Routes array (library of available routes)
- Links array (connections between routes at identical systems)
- Baked route (flat array, computed when active)
- Jump history (complete record of all jumps taken)
- State: planned/active/completed/ended

**Link** (unidirectional):
- System name/ID (must match in both routes)
- From: route_id + jump_index (cached)
- To: route_id + jump_index (cached)

**Baked Route** (active expeditions only):
- Pre-computed flat array of all jumps in order
- `current_baked_index` tracks progress
- `baked_loop_back_index` for circular routes (null if non-circular)

## Implementation Patterns

### Model Architecture

- All models are Go structs with JSON tags
- All models need `MarshalJSON`/`UnmarshalJSON` for file I/O
- Nested objects must be validated (e.g., Link.from_pos and Link.to_pos are required)

### Validation Rules

**What gets validated:**
- Link system_id must match in both routes at specified jump indices
- No multiple outgoing links from same (route_id, jump_index) position
- Cycle detection when creating links (warn user, don't block)

**What does NOT get validated:**
- Fuel requirements (trust plotter)
- Jump range feasibility (trust plotter)
- Distance consistency (trust plotter)
- Permit requirements (user responsibility)

### FSDJump Processing Logic

When processing Elite Dangerous journal FSDJump events:

1. Get next expected system from `baked_route[current_baked_index + 1]`
2. Compare jump system_id with expected
3. Record in jump_history with flags: `on_route`, `expected`
4. If on-route: increment `current_baked_index` (or wrap to `baked_loop_back_index` if circular)
5. If reached end and non-circular: transition to `completed`
6. **Always copy next expected system to clipboard** (even during deviations)

### State Transitions

- `planned` → `active`: Bake route, lock structure, start tracking
- `active` → `completed`: Auto-detect when reached end (non-circular only)
- `active` → `ended`: Manual stop (with confirmation)
- No reverse transitions (immutable historical records)

## Critical Design Decisions

1. **Routes are immutable** - No editing after creation. Need changes? Generate new route.
2. **One active expedition** - Enforced at index.json level
3. **Links connect identical systems** - Same system_id in both routes, different jump indices
4. **No branching during travel** - Path must be unambiguous (max one outgoing link per position)
5. **Circular routes allowed** - Detected via `baked_loop_back_index`, must be manually ended
6. **Save after every FSDJump** - ~40+ seconds between jumps, I/O not a concern

## Edge Cases & Gotchas

1. **System appears multiple times in route** - Valid! Each occurrence can have different link
2. **Circular expeditions** - Never auto-complete, must manually end
3. **Starting mid-route** - Expedition.start can point to any jump_index, not just 0
4. **Unlinked routes in expedition** - Valid! Routes are a library, not all need to be connected
5. **Jump index caching** - Link jump indices are cached; validate on load, search route if invalid
6. **Empty routes not allowed** - Must have at least 1 jump
7. **Missing jumps (app offline)** - On startup, detect position mismatch, optionally fill synthetic history

## v1 Scope

**In scope:**
- Spansh plotter only
- Full state machine (planned/active/completed/ended)
- Baked routes with circular support
- Auto-copy to clipboard
- Complete deviation tracking
- JSON file storage

**Out of scope:**
- Multiple plotter support
- Multi-device sync
- Expedition cloning
- Route editing
- Ship change detection
- Advanced validation (fuel, range, permits)

## File Organization

**Naming conventions:**
- Go packages/files: `snake_case` (e.g., `app_state.go`, `spansh_data.go`)
- Cmd binaries: `kebab-case` (e.g., `cmd/journal-watcher-test/`)

**Directory structure:**
```
/
├── main.go              # Wails app entry point (requires -j flag for journal dir)
├── app.go               # Main app struct with exported methods
├── cmd/                 # Standalone utilities (kebab-case naming)
│   ├── journal-watcher-test/    # Test journal monitoring
│   ├── simulate-log/            # Simulate journal writes
│   ├── expected-events/         # Show expected events from test data
│   └── prune-spansh-data/       # Strip spansh.data.json to minimal fields
├── database/            # JSON file I/O and OS-specific data paths
│   ├── json.go          # ReadJSON[T], WriteJSON[T] (atomic writes)
│   └── directories.go   # PathFor, GetDataDir, AppStatePath, IndexPath
├── journal/             # Elite Dangerous journal event processing
│   ├── watcher.go       # File watching with fsnotify, fanout channels
│   └── events.go        # Event type definitions (FSDJump, Loadout, FSDTarget)
├── models/              # Data structures (snake_case files)
│   ├── route.go         # Immutable route from plotter
│   ├── expedition.go    # Expedition state machine
│   ├── index.go         # ExpeditionIndex (active expedition tracking)
│   └── app_state.go     # AppState with minimal Loadout for spansh params
├── services/            # Business logic layer
│   ├── app_state.go          # Tracks loadout from journal, updates app state
│   ├── expedition.go         # Core service + FSD jump event processing
│   ├── expedition_edit.go    # CRUD operations (routes, links, renaming)
│   └── expedition_lifetime.go # State transitions (create, start, end, complete, delete)
├── plotters/            # Plotter integration
│   ├── spansh_data.go   # go:embed spansh reference data (FSD modules, boosters)
│   └── spansh.data.json # Pruned spansh data (embedded in binary)
├── lib/                 # Shared utilities
│   ├── channels/fanout.go  # Generic fanout channel for pub/sub
│   ├── slice/main.go       # Find, Split, Count helpers
│   └── fs/main.go          # IsDir helper
└── frontend/
    └── src/
        ├── App.svelte
        ├── components/      # Generic reusable UI components
        ├── features/        # Feature-specific components (expeditions/, routes/)
        ├── lib/
        │   └── utils/       # Shared utilities (date formatting, etc.)
        └── wailsjs/         # Generated Go bindings
```

## Frontend Development Workflow

**CRITICAL:** Before implementing frontend features, load the `frontend` skill. It contains the component inventory, CSS rules, and patterns that prevent duplicate implementations.

## Architecture Patterns

### Service Layer

Services handle business logic and event orchestration. Each service:
- Has `Start()` / `Stop()` methods for lifecycle management
- Stores subscription channels for cleanup
- Uses fanout channels from journal watcher for events

**Example pattern:**
```go
type AppStateService struct {
    state       *models.AppState
    watcher     *journal.Watcher
    loadoutChan chan *journal.LoadoutEvent  // Store for cleanup
}

func (s *AppStateService) Start() {
    s.loadoutChan = s.watcher.Loadout.Subscribe()
    go func() {
        for event := range s.loadoutChan {
            // Process event, update state, save
        }
    }()
}

func (s *AppStateService) Stop() {
    if s.loadoutChan != nil {
        s.watcher.Unsubscribe(s.loadoutChan)
        s.loadoutChan = nil  // Prevent double-cleanup
    }
}
```

### Database Layer

**Atomic writes:** `database.WriteJSON` uses temp file + rename pattern to prevent corruption.

**Generic functions:** `ReadJSON[T]` and `WriteJSON[T]` use Go generics for type safety.

**Model persistence:** Package-level `Load*` and `Save*` functions (not methods).

### Journal Watcher

The journal watcher monitors Elite Dangerous journal files and publishes events via fanout channels.

**Key Components:**
- `journal.Watcher` - Main watcher with `Start()`, `Stop()`, `Sync()` methods
- `lib/channels.FanoutChannel` - Pub/sub channels for event distribution
- Logger required for trace logging

**Initialization:**
```go
watcher, err := journal.NewWatcher(journalDir, logger)
defer watcher.Close()
```

**Event Channels** (all require subscription):
- `watcher.Loadout` - Ship loadout changes
- `watcher.FSDJump` - FSD jump events
- `watcher.FSDTarget` - FSD target selection
- `watcher.Location` - Location events

**Sync Behavior** (`watcher.Sync(since time.Time)`):
- Reads all journal files at/after the provided timestamp
- Conservative cutoff: starts reading from earlier journals to avoid missing events
- Timestamp filtering: only publishes events after `since` timestamp
- Must be called **before** `Start()` (returns error if watcher already started)
- Typical usage: sync from last known location timestamp on app startup

**FanoutChannel Details:**
- Requires name (for trace logs), buffer size, timeout, and logger
- Named channels: `"Loadout"`, `"FSDJump"`, `"FSDTarget"`, `"Location"`
- Publish timeout: 200ms (prevents blocking if subscriber is slow)
- Trace logs show per-listener delivery status

**Testing:**
- `TestLogger` - No-op implementation for silent tests
- `RecordingLogger` - Captures trace messages for assertions

### Plotter System

**Interface Design** (`plotters/main.go`):
```go
type Plotter interface {
    Plot(from, to string, inputs PlotterInputs, loadout *models.Loadout) (*models.Route, error)
    InputConfig() PlotterInputConfig
}
```

**Input Configuration**:
- `PlotterInputType`: Matches JS `typeof` - `string`, `number`, `boolean`
- `PlotterInputFieldConfig`: Defines input field with `Type`, `Default`, `Info` (description), `Options` (for selects)
- `PlotterInputOption`: Select options with `Value`, `Label`, `Description`
- `PlotterInputs`: `map[string]string` - all values encoded as strings
- **Value Encoding**: Bools as "1"/"0", numbers as string floats, strings direct
- **Select Inputs**: Any type can have `Options` to render as dropdown

**Helper Functions** (package-level in `plotters/main.go`):
- `getBoolInput()`, `getNumberInput()`, `getStringInput()` - Get with defaults
- `encodeBool()` - Convert bool to "1"/"0"
- `parseFloat()` - String to float64
- `resolveOptional()`, `oneOf()`, `get()` - Pointer helpers for nil handling

**Spansh Galaxy Plotter** (`plotters/spansh_galaxy_plotter.go`):
- **Embedded data**: `plotters/spansh.data.json` embedded via `go:embed`
- **Input config**: All routing options with descriptions from Spansh UI
- **Query params**: Builds complete parameter set including loadout-derived values (optimal_mass, fuel_multiplier, etc.)
- **FSD/Booster lookup**: Uses embedded spanshData for module defaults
- **Prune utility**: `cmd/prune-spansh-data` strips full spansh data to minimal required fields

### Wails Bindings Pattern

Adding backend functionality exposed to frontend follows this layered approach:

**1. Service Layer** (`services/`):
- Implement business logic in the appropriate service
- Handle domain-specific operations (validation, state management, persistence)
- Services are injected into App via constructor
- Example: `ExpeditionService.RemoveRouteFromExpedition()`

**2. App Layer** (`app.go`):
- Export methods on `App` struct - these become JavaScript bindings
- Methods should orchestrate, not implement - call services, load models, coordinate operations
- Keep thin - delegate complex logic to services
- Handle cross-service coordination if needed
- Example: `PlotRoute()` - gets loadout from AppStateService, calls plotter, adds route via ExpeditionService

**3. Model Layer** (`models/`):
- Package-level `Load*` and `Save*` functions for persistence
- Methods on models for computed properties or validation (e.g., `IsEditable()`)
- Struct fields with JSON tags for serialization

**4. Auto-Generated Bindings**:
- Wails auto-generates TypeScript definitions from exported App methods
- Types generated in `frontend/wailsjs/go/main/App.d.ts` and `App.js`
- Model types in `frontend/wailsjs/go/models.ts`
- Live reload during `wails dev` regenerates bindings automatically

**5. Frontend Integration** (`frontend/src/`):
- Import from `wailsjs/go/main/App`
- Call async - all bindings return Promises
- Handle errors appropriately (user-facing messages, console logs)
- Reload data after mutations to sync with backend state
- Example: `await RemoveRouteFromExpedition(expeditionId, routeId)`

**Important considerations:**
- Return types must be JSON-serializable
- Error handling: return `error` in Go, handle in frontend
- State updates: backend is source of truth - reload after mutations
- No manual binding generation needed - Wails handles it

**Example flow (removing a route):**
1. Service: `RemoveRouteFromExpedition()` - validates, modifies expedition, saves
2. App: `RemoveRouteFromExpedition()` - delegates to service
3. Wails: Auto-generates TS bindings
4. Frontend: Calls binding, handles response, reloads expedition data

## Important Notes

- **Journal integration:** App requires `-j` flag pointing to Elite Dangerous journal directory
- **Clipboard:** Auto-copy system name after each jump (no manual interaction)
- **Thread safety:** Use mutex locks for concurrent access to expedition state
- **Error handling:** WIP - currently using panics for early development, needs proper handling
- **Nil safety:** Go does NOT auto-handle nil - always check before dereferencing pointers
